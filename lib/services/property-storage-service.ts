/**
 * Property Storage Service
 * Handles dual storage: filesystem JSON + Supabase database
 *
 * **Next.js File System Access:**
 * Node.js fs module works in API routes and server components.
 * Never accessible from client-side code (browser).
 * This is a key difference from SPA - we have direct filesystem access!
 *
 * **Dual Storage Strategy:**
 * 1. Filesystem JSON - Fast local caching, Git-trackable
 * 2. Supabase DB - Queryable, scalable, production-ready
 * Both synced automatically on every property save
 */

import fs from 'fs/promises'
import path from 'path'
import { IntelligentPropertyResult } from '@/lib/types/property-intelligence'
import { supabase } from '@/lib/utils/supabase-client'

export class PropertyStorageService {
    private readonly storageDir: string

    constructor() {
        // Store in data/properties directory relative to project root
        this.storageDir = path.join(process.cwd(), 'data', 'properties')
    }

    /**
     * Generate URL-safe slug from property name
     */
    public generateSlug(title: string): string {
        return title
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '')
            .substring(0, 100) // Limit length
    }

    /**
     * Ensure storage directory exists
     */
    private async ensureStorageDir(): Promise<void> {
        try {
            await fs.access(this.storageDir)
        } catch {
            await fs.mkdir(this.storageDir, { recursive: true })
            console.log(`[Storage] Created storage directory: ${this.storageDir}`)
        }
    }

    /**
     * Sync property to Supabase database
     *
     * Transforms property object to match society table schema
     * Uses upsert to prevent duplicates (insert if new, update if exists)
     */
    private async syncToSupabase(property: IntelligentPropertyResult, slug: string): Promise<void> {
        console.log(`[Storage] üîÑ Starting Supabase sync for: ${slug}`)
        console.log(`[Storage] üì§ Attempting to sync with Supabase...`)

        try {
            // Transform property to match DB schema
            // Note: id is auto-generated by database (identity column)
            const dbRecord = {
                name: property.title, // ‚Üê Renamed: title ‚Üí name
                description: property.description,

                // JSONB columns (nested objects)
                specifications: property.specifications,
                location: property.location,
                community: property.community,
                market: property.market,
                narratives: property.narratives,

                // Metadata
                confidence_score: property.confidenceScore,
                source_url: property.sourceUrl,
                source_name: property.sourceName,
                last_analyzed: property.lastAnalyzed,
                search_score: property.searchScore || 0,

                // Arrays (JSONB)
                source_analyses: property.sourceAnalyses || [],
                source_citations: property.sourceCitations || [],
                property_images: property.propertyImages || [],

                // Storage metadata
                stored_at: new Date().toISOString(),
                slug: slug
            }

            console.log(`[Storage] üì§ Upserting to Supabase table: society`)
            console.log(`[Storage] üìù Property Name: ${dbRecord.name}, Slug: ${dbRecord.slug}`)
            console.log(`[Storage] üî¢ Record size: ${JSON.stringify(dbRecord).length} characters`)

            // Upsert: Insert if new, update if exists (by slug)
            const { data, error } = await supabase
                .from('society')
                .upsert(dbRecord as any, {
                    onConflict: 'slug', // Use slug as unique identifier
                    ignoreDuplicates: false // Update if exists
                })
                .select() // Return the upserted row

            if (error) {
                console.error(`[Storage] ‚ùå Supabase sync failed:`, error.message)
                console.error(`[Storage] üî¥ Error code:`, error.code)
                console.error(`[Storage] üî¥ Error hint:`, error.hint)
                console.error(`[Storage] üî¥ Error details:`, error.details)
                console.error(`[Storage] üî¥ Full error object:`, JSON.stringify(error, null, 2))
            } else {
                console.log(`[Storage] ‚úÖ Synced to Supabase: ${slug}`)
                console.log(`[Storage] üìä Upserted data:`, data ? `${data.length} row(s) returned` : 'No data returned')
            }
        } catch (err: any) {
            console.error(`[Storage] ‚ùå Supabase sync exception:`)
            console.error(`[Storage] üî¥ Exception type:`, err?.constructor?.name)
            console.error(`[Storage] üî¥ Exception message:`, err?.message)
            console.error(`[Storage] üî¥ Exception cause:`, err?.cause)
            console.error(`[Storage] üî¥ Exception stack:`, err?.stack)
            console.error(`[Storage] üî¥ Full exception:`, err)
        }
    }

    /**
     * Store property intelligence as JSON file + sync to Supabase
     *
     * Dual storage strategy:
     * 1. Save to filesystem (fast, Git-trackable)
     * 2. Sync to Supabase (queryable, scalable)
     */
    async storeProperty(property: IntelligentPropertyResult): Promise<string> {
        await this.ensureStorageDir()

        const slug = this.generateSlug(property.title)
        const filename = `${slug}.json`
        const filepath = path.join(this.storageDir, filename)

        // Add metadata
        const storedData = {
            ...property,
            storedAt: new Date().toISOString(),
            slug
        }

        // Phase 1: Save to filesystem (primary storage)
        await fs.writeFile(filepath, JSON.stringify(storedData, null, 2), 'utf-8')
        console.log(`[Storage] üíæ Stored property: ${filename}`)

        // Phase 2: Sync to Supabase (secondary storage - non-blocking)
        await this.syncToSupabase(storedData, slug)

        return slug
    }

    /**
     * Get property by slug
     */
    async getPropertyBySlug(slug: string): Promise<IntelligentPropertyResult | null> {
        try {
            const filepath = path.join(this.storageDir, `${slug}.json`)
            const data = await fs.readFile(filepath, 'utf-8')
            const property = JSON.parse(data)

            console.log(`[Storage] Retrieved property: ${slug}`)
            return property
        } catch (error) {
            console.log(`[Storage] Property not found: ${slug}`)
            return null
        }
    }

    /**
     * Check if property exists in cache
     */
    async propertyExists(title: string): Promise<boolean> {
        const slug = this.generateSlug(title)
        const filepath = path.join(this.storageDir, `${slug}.json`)

        try {
            await fs.access(filepath)
            return true
        } catch {
            return false
        }
    }

    /**
     * Get cached property by title
     */
    async getCachedProperty(title: string): Promise<IntelligentPropertyResult | null> {
        const slug = this.generateSlug(title)
        return this.getPropertyBySlug(slug)
    }

    /**
     * List all cached properties
     */
    async listCachedProperties(): Promise<string[]> {
        try {
            await this.ensureStorageDir()
            const files = await fs.readdir(this.storageDir)
            return files
                .filter(f => f.endsWith('.json'))
                .map(f => f.replace('.json', ''))
        } catch {
            return []
        }
    }

    /**
     * Delete cached property
     */
    async deleteProperty(slug: string): Promise<boolean> {
        try {
            const filepath = path.join(this.storageDir, `${slug}.json`)
            await fs.unlink(filepath)
            console.log(`[Storage] Deleted property: ${slug}`)
            return true
        } catch {
            return false
        }
    }

    /**
     * Check cache age and determine if refresh needed
     */
    async shouldRefreshCache(title: string, maxAgeHours: number = 24): Promise<boolean> {
        const property = await this.getCachedProperty(title)

        if (!property) return true // Not cached, need to fetch

        const storedAt = (property as any).storedAt
        if (!storedAt) return true // No timestamp, refresh

        const cacheAge = Date.now() - new Date(storedAt).getTime()
        const maxAge = maxAgeHours * 60 * 60 * 1000

        return cacheAge > maxAge
    }
}

/**
 * Singleton instance
 */
let storageInstance: PropertyStorageService | null = null

export function getPropertyStorage(): PropertyStorageService {
    if (!storageInstance) {
        storageInstance = new PropertyStorageService()
    }
    return storageInstance
}